#!/usr/bin/env bash
#
# git-reltag
#   subcommands to add/checkout new signed tags based on last tag in branch
#
# tagging:
#   patch: add new signed tag 'release-<X>.<Y>.<Z+1>'
#   minor: add new signed tag 'release-<X>.<Y+1>.0'
#   major: add new signed tag 'release-<X+1>.0.0'
#
# checkout:
#   next: fetch && verify-tag && checkout, lex next release-X.Y.Z
#   prev: fetch && verify-tag && checkout, lex prev release-X.Y.Z
#   sync: fetch && verify-tag && checkout, lex last release-X.Y.Z
#   ver: fetch && verify-tag && checkout, exact given release tag $1
#   tag: alias for 'patch' (canonical name, original script)
#
# note:
#   - only fully committed repos can proceed
#   - for tags, current checkout must be ahead of last tag
#   - for checkouts, must be an exact detached tag checkout already
#
# todo:
#   - allow prefix to be specified; currently hardcoded ('release-')
#   - eval "$varname['foo']=$foo" should be hidden behind an interface
#   - can we make these tags already with some kind of git printfs
#     rather than parsing its 'describe' output with a regex?
#
# stat:
#   - used by author
#   - most codepaths debugged, some remain
#   - please inform if using
#
# scott@smemsh.net
# http://smemsh.net/src/git-reltag/
# http://spdx.org/license/GPL-2.0
#
##############################################################################

# tags from current checkout are parsed from 'describe' into a
# $release[] dictionary that contains the commit hash, how many
# changes we are away from last tag, and what its name was, eg:
# release-1.0.4-5-g41f7b4f76d51119fe91d2e14c9ea1c021713b015
#
relpat=(
	prefix	'^(release)-'
	major	'([[:digit:]]+)\.'
	minor	'([[:digit:]]+)\.'
	patch	'([[:digit:]]+)-'
	changes	'([[:digit:]]+)-'
	commit	'g([0-9a-f]+)$'
)

###

bomb () { echo "$@" >&2; exit 1; }

###

# TODO: we should do a lot more here
#
verify_sanity_exit ()
{
	test -d .git || bomb "no gitdir"
	test -w .git || bomb "cannot write to gitdir"
	changes_pending && bomb "aborting while changes are pending"
}

# - parses 'git describe' output into dictionary var (named as $1)
# - branch name of given refspec (supplied in $2) stored in 'branch' field
# - assigns values to fields named in $relpat[] (release pattern regex)
# - $message[] array contains string of "name: val\n" pairs for 'git tag -m'
# - reason for $1: formerly, was called twice to build two
#                  different arrays (TODO: maybe don't care now?)
#
slurp_tags ()
{
	local idx val
	declare -g pattern
	declare -a fields patterns

	local varname="${1:?}"
	local refspec="${2:?}"

	# create integer-indexed arrays we can use to map associative
	# indices with parsed substrings from $relpat[]
	#
	for ((i = 0; i < ${#relpat[@]};)); do
		fields+=(${relpat[i++]})
		patterns+=(${relpat[i++]})
	done

	# get git-describe output for the given refspec ($2)
	#
	local IFS=''; pattern="${patterns[*]}"; unset IFS
	local desc=$(git describe --abbrev=999 --long $refspec)

	# parse into fields of given-named ($1) associative array
	#
	# WARNING: only add to $fields[] after this block, otherwise
	# offsets won't match index with $pattern subexpressions
	# TODO: make that impossible somehow, probably write an
	# interface to modify $varname
	#
	if [[ $desc =~ $pattern ]]; then
		for ((i = 0; i < ${#fields[@]};)); do
			idx=${fields[i]}
			val="${BASH_REMATCH[++i]}"
			eval "$varname[$idx]=$val"
		done
	else
		bomb "no match on 'describe' output"
	fi

	###

	fields+=('desc')
	eval "$varname['desc']=$desc"

	# add branch name of the given ref, which should
	# resolve empty (detached head) for checkout case
	# (we are only to be run from an unchanged exact tag)
	# (this is tested for in do_checkout())
	#
	fields+=('branch')
	local branchname=$(basename "$(git symbolic-ref -q $refspec)")
	eval "$varname['branch']='$branchname'"

	# reassemble conventional short tag name and store for
	# later test of tag match to find out what offset we
	# are into sorted tag name array
	#
	local tagmembers=(
		${release[prefix]}-
		${release[major]}.
		${release[minor]}.
		${release[patch]}
	)
	fields+=('prior')
	local IFS=; eval "$varname['prior']='${tagmembers[*]}'"; unset IFS

	###

	# some fields we don't want in the tag message: empty ones, or
	# emphemeral ones used to construct desired new tag name, which
	# can be confusing if inserted into the tag message so we skip
	#
	maybe_append_field_to_tag_message ()
	{
		local var=$1 field=$2; shift 2

		# message will only even be used when adding a tag
		#
		is_tagging_op ||
			return

		# if not blank,
		#
		if (($# > 0))
		then
			# and not one of the discarded fields names
			#
			if [[
				$field == 'major' ||
				$field == 'minor' ||
				$field == 'patch' \
			]]; then
				continue
			else
				# then stash field in the tag message
				#
				local IFS=; local val="$*"; unset IFS
				message+=("$field: $val")
			fi
		else
			# skip any empty fields
			continue
		fi
	}

	# create checkin message with [non-empty] text of all
	# field names and values, storing result in $message[]
	#
	for ((i = 0; i < ${#fields[@]}; i++))
	do
		idx=${fields[i]}
		eval val="\${$varname[$idx]}"
		maybe_append_field_to_tag_message \
			$varname $idx "$val"
	done
}

determine_desired_tag ()
{
	local ntags

	if ((${release[changes]} != 0)); then
		bomb "starting checkout must be at an exact tag"; fi

	taglist=($(git tag -l --sort=version:refname))

	for ((i = 0, ntags = ${#taglist[@]}; i < ntags; i++))
	do
		if [[ ${tags['exact']} ]]
		then
			if [[ ${tags['exact']} == ${taglist[i]} ]]
			then
				return
			fi
		elif [[ ${taglist[i]} == ${release['prior']} ]]
		then
			tags['cur']=${taglist[i]}
			tags['prev']=${taglist[i-1]}
			tags['next']=${taglist[i+1]}
			tags['last']=${taglist[ntags-1]}
			return
		fi
	done

	# no matching tags found
	#
	false; return
}

# make sure to properly obtain exit code of verify
# pipeline while postprocessing its output
#
verify_tag ()
{
	# we run this in a subshell to save pipefail
	# (TODO save and restore the setting instead?)
	# maybe pipefail should just be set at script
	# top, seems like better default anyways
	#
	(
		set -o pipefail
		git verify-tag -v $1 2>/dev/null \
		| awk '/^$/ { while (getline) print $0; }'
	)
}

# so we can make sure to run only on clean checkouts
#
working_changes () { ! git diff --exit-code &>/dev/null; }
staged_changes  () { ! git diff --cached --exit-code &>/dev/null; }
changes_pending () { working_changes || staged_changes; }

##############################################################################

do_checkout ()
{
	local tagmember=${1:?}
	local exactver=$2

	local tag
	declare -A tags
	declare -a taglist

	is_checkout_op ||
		bomb "do_checkout invoked for non-checkout scenario"

	# make sure we have latest copy of refs and tags
	#
	git fetch ||
		bomb "fetch failure"

	# we should be in detached head state (no branch) for
	# the release checkout we run from; if we are actually
	# on a branch, something is wrong (probably, run from
	# wrong checkout)
	#
	[[ ${release['branch']} ]] &&
		bomb "checkout must be detached already"

	# if invoked as git-relver, we stuff $tags['exact'] to
	# tell determine_desired_tag() we want to bypass
	# calculating a version and go straight to the
	# designated one (this still verifies tag exists and
	# has the proper signature)
	#
	if [[
		$invname == 'ver' &&
		$tagmember == 'exact' &&
		$exactver \
	]]; then
		# we don't have to extend $fields[] along with
		# the var set because this will never get
		# written for do_checkout() unlike do_tag()
		#
		tags['exact']=${release['prefix']}-$exactver
	fi

	# determine what tag we match, and the next and
	# previous ones if we care about those (see $tags[])
	#
	determine_desired_tag ||
		bomb "failed to determine desired tag"

	###

	local tag=${tags[$tagmember]}
	[[ $tag ]] || bomb "no '$tagmember' tag found"

	verify_tag $tag ||
		bomb "tag verify failed: '$tag'"

	git checkout -q $tag ||
		bomb "checkout failed: '$tag'"
}

do_tag ()
{
	local tagname

	is_tagging_op ||
		bomb "do_tag invoked with non-tag operation"

	[[ ${release[branch]} ]] ||
		bomb "head detached, must be run from a branch"

	((${release[changes]} == 0)) &&
		bomb "no changes since last tag made, aborting"

	tagname=${release[prefix]}-$1.$2.$3
	message+=('tagname: $tagname')

	local IFS=$'\n'; msg="${message[*]}"; unset IFS

	if git tag -s $tagname -F - <<< "$msg"
	then
		echo "tag $tagname successfully created with message:"
		echo "$msg"
	else
		bomb "tag create failed: '$tagname'"
	fi
}

##############################################################################

call ()
{
	func=$1; shift

	if [[ `declare -F _$func` ]]
	then _$func "$@"
	else echo "$func: unimplemented" >&2; _help; false
	fi
}

main ()
{
	if (($# == 0))
	then _help; bomb "must supply subcommand as argument"
	else invname=$1; shift; fi

	verify_sanity_exit

	# - create $release[] dictionary indexed by 'git describe'
	#   fields from the local checked out branch into $release[]
	#
	declare -A release
	slurp_tags release HEAD

	# make separate integers from release vars so we can do math
	# on them succinctly to make the new (desired) tag name
	#
	if is_tagging_op
	then
		# for building tag name
		declare -g \
		patchlvl=${release[patch]} \
		majorlvl=${release[major]} \
		minorlvl=${release[minor]} \
		;
		# carries commit message "field: value" strings
		declare -a message
	fi

	call $invname "$@" ||
		bomb "$invname: failed"
}

##############################################################################

is_tagging_op   () { [[ $invname =~ ^(patch|minor|major|tag)$   ]]; }
is_checkout_op  () { [[ $invname =~ ^(sync|next|prev|ver)$      ]]; }

_patch   () { do_tag $majorlvl $minorlvl $((++patchlvl)); }
_minor   () { do_tag $majorlvl $((++minorlvl)) 0; }
_major   () { do_tag $((++majorlvl)) 0 0; }
_sync    () { do_checkout last; }
_next    () { do_checkout next; }
_prev    () { do_checkout prev; }
_ver     () { do_checkout exact $1; }

_tag     () { _relpatch "$@"; }
_help    () { declare -F | awk '{print $3}' | grep ^_ | sed s,.,,; }

##############################################################################

main "$@"
