#!/usr/bin/env bash
#
# git-reltag
#   subcommands to add/checkout new signed tags based on last tag in branch
#
# tagging:
#   patch: add new signed tag 'release-<X>.<Y>.<Z+1>'
#   minor: add new signed tag 'release-<X>.<Y+1>.0'
#   major: add new signed tag 'release-<X+1>.0.0'
#   init:  add new signed tag 'release-0.0.0' (use for first tag)
#
# checkout:
#   next: fetch && verify-tag && checkout, lex next release-X.Y.Z
#   prev: fetch && verify-tag && checkout, lex prev release-X.Y.Z
#   sync: fetch && verify-tag && checkout, lex last release-X.Y.Z
#   ver:  fetch && verify-tag && checkout, exact given release tag $1
#   tag:  alias for 'patch' (canonical name, original script)
#
# note:
#   - only fully committed repos can proceed
#   - for tags, current checkout must be ahead of last tag
#   - for checkouts, must be an exact detached tag checkout already
#
# todo:
#   - allow prefix to be specified; currently hardcoded ('release-')
#   - allow a suffix string to be specified also
#   - can we make these tags already with some kind of git printfs
#     rather than parsing its 'describe' output with a regex?
#
# stat:
#   - used by author
#   - most codepaths debugged, some remain
#   - please inform if using
#
# scott@smemsh.net
# http://smemsh.net/src/git-reltag/
# http://spdx.org/license/GPL-2.0
#
##############################################################################

# all tags we make will have this string prefixed to the version
#
tagprefix=release

# tags from current checkout are parsed from 'describe' into a
# $release[] dictionary that contains the commit hash, how many
# changes we are away from last tag, and what its name was, eg:
# release-1.0.4-5-g41f7b4f76d51119fe91d2e14c9ea1c021713b015
#
relpat=(
	prefix	"^($tagprefix)-"
	major	'([[:digit:]]+)\.'
	minor	'([[:digit:]]+)\.'
	patch	'([[:digit:]]+)-'
	changes	'([[:digit:]]+)-'
	commit	'g([0-9a-f]+)$'
)

###

warn        () { echo "$@" >&2; }
bomb        () { echo "$@" >&2; exit 1; }

strcat      () { strdelim '' "$@"; }
strdelim    () { (($# >= 2)) || return; local IFS="$1"; shift; printf "$*"; }

##############################################################################

# TODO: we should do a lot more here
#
verify_sanity_exit ()
{
	test -d .git || bomb "no gitdir"
	test -w .git || bomb "cannot write to gitdir"
	changes_pending && bomb "aborting while changes are pending"
}

# - parses 'git describe' (or 'show' for initial tag) into $release[] dict
# - assigns values to fields named in $relpat[] (release pattern regex)
# - branch name of checkout stored in 'branch' field
# - $message[] array contains string of "name: val\n" pairs for 'git tag -m'
#
slurp_checkout ()
{
	local idx val
	local pattern desc commit
	declare -a fields patterns

	# create integer-indexed arrays we can use to map associative
	# indices with parsed substrings from $relpat[]
	#
	for ((i = 0; i < ${#relpat[@]};)); do
		fields+=(${relpat[i++]})
		patterns+=(${relpat[i++]})
	done

	if [[ $invname == 'init' ]]
	then
		# first tag won't have any of the previous tag
		# info, we only want to store the commit hash
		#
		commit=`git show --no-patch --pretty=format:%H`
		[[ $commit ]] ||
			bomb "unable to determine commit hash"
		release['commit']="$commit"

		# (since we don't do regex match of recent tag for init)
		#
		release['prefix']=$tagprefix
	else
		# parse into fields of given-named ($1) associative
		# array WARNING: only add to $fields[] after this block,
		# otherwise offsets won't match index with $pattern
		# subexpressions
		# TODO: make that impossible somehow, probably write
		# an interface to modify $varname
		#
		desc=`git describe --abbrev=999 --long HEAD`
		pattern=`strcat "${patterns[@]}"`
		if [[ $desc =~ $pattern ]]; then
			for ((i = 0; i < ${#fields[@]};)); do
				idx=${fields[i]}
				val="${BASH_REMATCH[++i]}"
				release[$idx]="$val"
			done
		else
			bomb "no match on 'describe' output, try 'init'"
		fi

		fields+=('desc')
		release['desc']="$desc"

		# reassemble conventional short tag name and store for
		# later test of tag match to find out what offset we
		# are into sorted tag name array
		#
		local tagmembers=(
			${release['prefix']}-
			${release['major']}.
			${release['minor']}.
			${release['patch']}
		)
		fields+=('prior')
		release['prior']="`strcat ${tagmembers[@]}`"
	fi

	# add branch name of the given ref, which should
	# resolve empty (detached head) for checkout case
	# (we are only to be run from an unchanged exact tag)
	# (this is tested for in do_checkout())
	#
	fields+=('branch')
	local branchname="`git symbolic-ref -q HEAD`"
	release['branch']="${branchname##*/}"

	###

	# some fields we don't want in the tag message: empty ones, or
	# emphemeral ones used to construct desired new tag name, which
	# can be confusing if inserted into the tag message so we skip
	#
	maybe_append_field_to_tag_message ()
	{
		local var=$1 field=$2; shift 2

		# message will only even be used when adding a tag
		#
		is_tagging_op ||
			return

		# if not blank,
		#
		if (($# > 0)) && [[ $1 ]]
		then
			# and not one of the discarded fields names
			#
			if [[
				$field == 'major' ||
				$field == 'minor' ||
				$field == 'patch' \
			]]; then
				continue
			else
				# then stash field in the tag message
				#
				val=`strcat "$@"`
				message+=("$field: $val")
			fi
		else
			# skip any empty fields
			continue
		fi
	}

	# create checkin message with [non-empty] text of all
	# field names and values, storing result in $message[]
	#
	for ((i = 0; i < ${#fields[@]}; i++))
	do
		idx=${fields[i]}
		val="${release[$idx]}"
		maybe_append_field_to_tag_message \
			$varname $idx "$val"
	done
}

determine_desired_tag ()
{
	local ntags

	taglist=(`git tag -l --sort=version:refname`)

	for ((i = 0, ntags = ${#taglist[@]}; i < ntags; i++))
	do
		if [[ ${tags['exact']} ]]
		then
			if [[ ${tags['exact']} == ${taglist[i]} ]]
			then
				return
			fi
		elif [[ ${taglist[i]} == ${release['prior']} ]]
		then
			tags['cur']=${taglist[i]}
			tags['prev']=${taglist[i-1]}
			tags['next']=${taglist[i+1]}
			tags['last']=${taglist[ntags-1]}
			return
		fi
	done

	# no matching tags found
	#
	false; return
}

# make sure to properly obtain exit code of verify
# pipeline while postprocessing its output
#
verify_tag ()
{
	# we run this in a subshell to keep pipefail setting,
	# and do it here to make it obvious during later
	# code edits to pay attention to verify-tag for security
	#
	(
		set -o pipefail
		git verify-tag -v $1 2>/dev/null \
		| awk '/^$/ { while (getline) print $0; }'
	)
}

# so we can make sure to run only on clean checkouts
#
working_changes () { ! git diff --exit-code &>/dev/null; }
staged_changes  () { ! git diff --cached --exit-code &>/dev/null; }
changes_pending () { working_changes || staged_changes; }

##############################################################################

do_checkout ()
{
	local tagmember=${1:?}
	local exactver=$2

	local tag
	declare -A tags
	declare -a taglist

	is_checkout_op ||
		bomb "do_checkout invoked for non-checkout scenario"

	if ((${release['changes']} != 0)); then
		bomb "starting checkout must be at an exact tag"; fi

	git fetch --quiet ||
		bomb "fetch failure"

	# we should be in detached head state (no branch) for
	# the release checkout we run from; if we are actually
	# on a branch, something is wrong (probably, run from
	# wrong checkout)
	#
	[[ ${release['branch']} ]] &&
		bomb "checkout must be detached already"

	# if invoked as git-relver, we stuff $tags['exact'] to
	# tell determine_desired_tag() we want to bypass
	# calculating a version and go straight to the
	# designated one (this still verifies tag exists and
	# has the proper signature)
	#
	if [[
		$invname == 'ver' &&
		$tagmember == 'exact' &&
		$exactver \
	]]; then
		# we don't have to extend $fields[] along with
		# the var set because this will never get
		# written for do_checkout() unlike do_tag()
		#
		tags['exact']=${release['prefix']}-$exactver
	fi

	# determine what tag we match, and the next and
	# previous ones if we care about those (see $tags[])
	#
	determine_desired_tag ||
		bomb "failed to determine desired tag"

	###

	local tag=${tags[$tagmember]}
	[[ $tag ]] ||
		bomb "no '$tagmember' tag found"

	[[ $tag == ${release['prior']} ]] &&
		bomb "desired tag already checked out"

	verify_tag $tag ||
		bomb "tag verify failed: '$tag'"

	git checkout -q $tag ||
		bomb "checkout failed: '$tag'"
}

do_tag ()
{
	local major=$1 minor=$2 patch=$3
	local tagname

	is_tagging_op ||
		bomb "do_tag invoked with non-tag operation"

	[[ ${release['branch']} ]] ||
		bomb "head detached, must be run from a branch"

	if [[ $invname != 'init' ]]; then
		if ((${release['changes']} == 0)); then
			bomb "no changes since last tag made, aborting"; fi; fi

	tagname=${release['prefix']}-$major.$minor.$patch
	message+=("tagname: $tagname")

	msg="$(strdelim $'\n' "${message[@]}")"

	if git tag -s $tagname -F - <<< "$msg"
	then
		echo "tag $tagname successfully created, commit message:"
		echo "$msg"
	else
		bomb "tag create failed: '$tagname'"
	fi
}

##############################################################################

call ()
{
	func=$1; shift

	if [[ `declare -F _$func` ]]
	then _$func "$@"
	else warn "$func: unimplemented"; _help; false
	fi
}

main ()
{
	invname=$1; shift

	declare -A release      # dictionary indexed by 'git describe' fields
	declare -ga message     # carries commit message "field: value" strings

	if ! is_valid_op; then
		warn "$invname: unrecognized command"; _help; false; exit; fi

	if [[ $invname == '--help' ||
		$invname == '-h' ||
		$invname == 'help' ]]; then _help; exit; fi

	if (($# == 0)); then
		_help; bomb "must supply subcommand as argument"; fi

	verify_sanity_exit "$@"

	slurp_checkout HEAD	# read metadata into $release[]

	if is_tagging_op
	then
		# keep version components in separate scalars we can
		# manipulate to build tag name without altering $release[] 
		#
		declare -g \
		patchlvl=${release['patch']} \
		majorlvl=${release['major']} \
		minorlvl=${release['minor']} \
		;
	fi

	call $invname "$@" ||
		bomb "$invname: failed"
}

##############################################################################

is_tagging_op   () { [[ $invname =~ ^(init|patch|minor|major|tag)$      ]]; }
is_checkout_op  () { [[ $invname =~ ^(sync|next|prev|ver)$              ]]; }
is_valid_op     () { is_tagging_op $invname || is_checkout_op $invname;     }

_init    () { do_tag 0 0 0; }
_patch   () { do_tag $majorlvl $minorlvl $((++patchlvl)); }
_minor   () { do_tag $majorlvl $((++minorlvl)) 0; }
_major   () { do_tag $((++majorlvl)) 0 0; }
_tag     () { _relpatch "$@"; }

_sync    () { do_checkout last; }
_next    () { do_checkout next; }
_prev    () { do_checkout prev; }
_ver     () { do_checkout exact $1; }

_help    () { declare -F | awk '{print $3}' | grep ^_ | sed s,.,,; }

##############################################################################

main "$@"
