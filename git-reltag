#!/usr/bin/env bash
#
# git-reltag
#   add or checkout signed tags based on last tag in branch
#
# release:
#   patch: add new signed tag '<branch>-<X>.<Y>.<Z+1>'
#   minor: add new signed tag '<branch>-<X>.<Y+1>.0'
#   major: add new signed tag '<branch>-<X+1>.0.0'
#   init:  add new signed tag '<branch>-0.0.0' (use for first tag)
#   tag:   alias for 'patch' (canonical name, original script)
#
# deploy:
#   sync: fetch && verify && checkout, last <branch>-<X>.<Y>.<Z>
#   next: fetch && verify && checkout, next <branch>-<X>.<Y>.<Z>
#   prev: fetch && verify && checkout, prev <branch>-<X>.<Y>.<Z>
#   ver:  fetch && verify && checkout, exact given release tag $1
#
# note:
#   - without any args, executes as if given 'patch'
#   - refuses action in uncommitted repositories (dirty work area)
#   - for tagging ops, checkout must have had commits since last tag
#   - for checkouts, current must be an exact detached tag already
#
# todo:
#   - allow user-specified tag prefix instead of branch name
#   - allow suffix string to be specified as well
#   - can we make these tags already with some kind of git printfs
#     rather than parsing 'describe' output with a regex?
#
# stat:
#   - used by author to develop and deploy
#   - most codepaths debugged, some remain, should write tests
#   - please inform if using
#
# scott@smemsh.net
# http://smemsh.net/src/git-reltag/
# http://spdx.org/licenses/GPL-2.0
#
##############################################################################

# regex of valid identifiers for tag prefix (we use branch name)
# cf: git-check-ref-format (we only allow a subset for now)
#
tagvalids='[[:alnum:]_-/]'

# tags from current checkout are parsed from 'describe' into a
# $release[] dictionary that contains the commit hash, how many
# changes we are away from last tag, and what its name was, eg:
# master-1.0.4-5-g41f7b4f76d51119fe91d2e14c9ea1c021713b015
#
relpat=(
	prefix	"^($tagvalids+)-"
	major	'([[:digit:]]+)\.'
	minor	'([[:digit:]]+)\.'
	patch	'([[:digit:]]+)-'
	changes	'([[:digit:]]+)-'
	commit	'g([0-9a-f]+)$'
)

###

warn        () { echo "$@" >&2; }
bomb        () { echo "$@" >&2; exit 1; }

strcat      () { strdelim '' "$@"; }
strdelim    () { (($# > 1)) && { local IFS="$1"; shift; printf -- "$*"; }; }

##############################################################################

verify_sanity_exit ()
{
	test -d .git || bomb "no gitdir"
	test -w .git || bomb "cannot write to gitdir"
	changes_pending && bomb "aborting while changes are pending"
}

# - parses 'git describe' (or 'show' for initial tag) into $release[] dict
# - assigns values to fields named in $relpat[] (release pattern regex)
# - branch name from closest tag to checkout stored in 'prefix' field
# - branch name of current checked out branch stored in 'branch' field
# - $message[] array contains string of "name: val\n" pairs for 'git tag -m'
#
slurp_checkout ()
{
	local idx val
	local pattern desc commit
	declare -a fields patterns

	# create integer-indexed arrays we can use to map associative
	# indices with parsed substrings from $relpat[]
	#
	for ((i = 0; i < ${#relpat[@]};)); do
		fields+=(${relpat[i++]})
		patterns+=(${relpat[i++]})
	done

	if [[ $command == 'init' ]]
	then
		# first tag won't have any of the previous tag info, we
		# only want to store the commit hash
		#
		commit=`git show --no-patch --pretty=format:%H`
		[[ $commit ]] ||
			bomb "unable to determine commit hash"
		release['commit']="$commit"
	else
		# parse describe output into fields of $release[] array
		#
		# WARNING: only add to $fields[] after this block,
		# otherwise offsets won't match index with $pattern
		# subexpressions
		# TODO: make that impossible somehow, probably write
		# an interface to modify $release[] dictionary
		#
		desc=`git describe --abbrev=999 --long HEAD`
		pattern=`strcat "${patterns[@]}"`
		if [[ $desc =~ $pattern ]]; then
			for ((i = 0; i < ${#fields[@]};)); do
				idx=${fields[i]}
				val="${BASH_REMATCH[++i]}"
				release[$idx]="$val"
			done
		else
			bomb "no match for pattern '$pattern'" \
				"in 'describe' output '$desc'," $'\n' \
				"try 'init' or use matching head"
		fi

		fields+=('desc')
		release['desc']="$desc"

		# reassemble conventional short tag name and store for
		# later test of tag match to find out what offset we
		# are into sorted tag name array
		#
		local tagmembers=(
			${release['prefix']}-
			${release['major']}.
			${release['minor']}.
			${release['patch']}
		)
		fields+=('prior')
		release['prior']="`strcat ${tagmembers[@]}`"
	fi

	# add branch name of current checkout
	# checkout ops: branch name should be empty (detached head),
	#   since we are only to be run from an unchanged exact tag
	#   (tested for in do_checkout())
	# tagging ops: branch name will be used as the tag prefix
	#
	fields+=('branch')
	local branchname="`git symbolic-ref -q HEAD`"
	release['branch']="${branchname##*/}"

	###

	# some fields we don't want in the tag message: empty ones, or
	# emphemeral ones used to construct desired new tag name, which
	# can be confusing if inserted into the tag message so we skip
	#
	maybe_append_field_to_tag_message ()
	{
		local field=$1; shift

		# message will only even be used when adding a tag
		#
		is_tagging_op ||
			return

		# if args were provided (after we shifted off field name)
		# and it's not blank,
		#
		if (($#)) && [[ $1 ]]
		then
			# ...and it's not one of the field names we discard,
			#
			if [[
				$field == 'major' ||
				$field == 'minor' ||
				$field == 'patch' \
			]]; then
				continue
			else
				# ...then stash field in the tag message array
				#
				val=`strcat "$@"`
				message+=("$field: $val")
			fi
		else
			# skip any empty fields
			continue
		fi
	}

	# create checkin message with [non-empty] text of all
	# field names and values, storing result in $message[]
	#
	for ((i = 0; i < ${#fields[@]}; i++))
	do
		idx=${fields[i]}
		val="${release[$idx]}"
		maybe_append_field_to_tag_message $idx "$val"
	done
}

determine_desired_tag ()
{
	local tag ntags

	taglist=($(git tag --list --sort=version:refname \
			"${release['prefix']}-*"))

	(($debug)) && declare -p taglist
	(($debug)) && declare -p release

	for ((i = 0, ntags = ${#taglist[@]}; i < ntags; i++))
	do
		if [[ ${tags['exact']} ]]
		then
			if [[ ${tags['exact']} == ${taglist[i]} ]]
			then
				return
			fi
		elif [[ ${taglist[i]} == ${release['prior']} ]]
		then
			(($debug)) && set -x
			tags['cur']=${taglist[i]}
			tags['prev']=${taglist[i-1]}
			tags['next']=${taglist[i+1]}
			tags['last']=${taglist[ntags-1]}
			(($debug)) && set +x
			true
			return
		fi
	done

	# no matching tags found
	#
	false; return
}

# make sure to properly obtain exit code of verify
# pipeline while postprocessing its output
#
verify_tag ()
{
	# we run this in a subshell to keep pipefail setting,
	# and do it here to make it obvious during later
	# code edits to pay attention to verify-tag for security
	#
	(
		set -o pipefail
		git verify-tag -v $1 2>/dev/null \
		| awk '/^$/ { while (getline) print $0; }'
	)
}

# so we can make sure to run only on clean checkouts
#
working_changes () { ! git diff --exit-code &>/dev/null; }
staged_changes  () { ! git diff --cached --exit-code &>/dev/null; }
changes_pending () { working_changes || staged_changes; }

##############################################################################

do_checkout ()
{
	local tagmember=${1:?}
	local exactver=$2

	local tag
	declare -A tags

	is_checkout_op ||
		bomb "do_checkout invoked for non-checkout scenario"

	if ((${release['changes']} != 0)); then
		bomb "starting checkout must be at an exact tag"; fi

	git fetch --quiet ||
		bomb "fetch failure"

	# we should be in detached head state (no branch) for
	# the release checkout we run from; if we are actually
	# on a branch, something is wrong (probably, run from
	# wrong checkout)
	#
	[[ ${release['branch']} ]] &&
		bomb "checkout must be detached already"

	# if invoked as reltag ver, we stuff $tags['exact'] to
	# tell determine_desired_tag() we want to bypass
	# calculating a version and go straight to the
	# designated one (this still verifies tag exists and
	# has the proper signature)
	#
	if [[
		$command == 'ver' &&
		$tagmember == 'exact' &&
		$exactver \
	]]; then
		# we don't have to extend $fields[] along with
		# the var set because this will never get
		# written for do_checkout() unlike do_tag()
		#
		tags['exact']=${release['prefix']}-$exactver
	fi

	# determine what tag we match, and the next and
	# previous ones if we care about those (see $tags[])
	#
	determine_desired_tag ||
		bomb "failed to determine desired tag"

	###

	local tag=${tags[$tagmember]}
	[[ $tag ]] ||
		bomb "no '$tagmember' tag found"

	[[ $tag == ${release['prior']} ]] &&
		bomb "desired tag already checked out"

	verify_tag $tag ||
		bomb "tag verify failed: '$tag'"

	git checkout -q $tag ||
		bomb "checkout failed: '$tag'"
}

do_tag ()
{
	local major=$1 minor=$2 patch=$3
	local tagname

	is_tagging_op ||
		bomb "do_tag invoked with non-tag operation"

	[[ ${release['branch']} ]] ||
		bomb "head detached, must be run from a branch"

	if [[ $command != 'init' ]]; then
		if ((${release['changes']} == 0)); then
			bomb "no changes since last tag made, aborting"; fi; fi

	tagname=${release['branch']}-$major.$minor.$patch
	message+=("tagname: $tagname")

	msg="$(strdelim $'\n' "${message[@]}")"

	if git tag -s $tagname -F - <<< "$msg"
	then
		echo "tag $tagname successfully created, commit message:"
		echo "$msg"
	else
		bomb "tag create failed: '$tagname'"
	fi
}

##############################################################################

call ()
{
	func=$1; shift

	if [[ `declare -F _$func` ]]
	then _$func "$@"
	else warn "$func: unimplemented"; _help; false
	fi
}

main ()
{
	command=$1; shift

	declare -A release      # dictionary indexed by 'git describe' fields
	declare -ga message     # carries commit message "field: value" strings

	if ! [[ $command ]]; then
		command=patch; fi

	if [[ $command == '--help' ||
		$command == '-h' ||
		$command == 'help' ]]; then _help; exit; fi

	if ! is_valid_op; then
		warn "$command: unrecognized command"; _help; false; exit; fi

	verify_sanity_exit "$@"

	slurp_checkout HEAD	# read metadata into $release[]

	if is_tagging_op
	then
		# keep version components in separate scalars we can
		# manipulate to build tag name without altering $release[] 
		#
		declare -g \
		patchlvl=${release['patch']} \
		majorlvl=${release['major']} \
		minorlvl=${release['minor']} \
		;
	fi

	call $command "$@" ||
		bomb "$command: failed"
}

##############################################################################

is_tagging_op   () { [[ $command =~ ^(init|patch|minor|major|tag)$      ]]; }
is_checkout_op  () { [[ $command =~ ^(sync|next|prev|ver)$              ]]; }
is_valid_op     () { is_tagging_op || is_checkout_op;     }

_init    () { do_tag 0 0 0; }
_patch   () { do_tag $majorlvl $minorlvl $((++patchlvl)); }
_minor   () { do_tag $majorlvl $((++minorlvl)) 0; }
_major   () { do_tag $((++majorlvl)) 0 0; }
_tag     () { _relpatch "$@"; }

_sync    () { do_checkout last; }
_next    () { do_checkout next; }
_prev    () { do_checkout prev; }
_ver     () { do_checkout exact $1; }

_help    () { declare -F | awk '{print $3}' | grep ^_ | sed s,.,,; }

##############################################################################

main "$@"
